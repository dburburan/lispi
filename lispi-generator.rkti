#lang lispi racket/base

;----------------------------------------------------------------------
; Lispi - Lisp with Indents: a minimalist alternative syntax.
;         Uses colons and indentation to avoid trailing parentheses.
;----------------------------------------------------------------------

;----------------------------------------------------------------------
; Pretty Printer
;----------------------------------------------------------------------
;
; We pretty print ourself into standard lisp syntax.
; This is what is actually loaded when Racket comes across "#lang lispi"
;
; This allows us to be self-hosted
;
;----------------------------------------------------------------------

require:
  racket/pretty

define: pretty-print-program: columns filename program
  define: output-file
    open-output-file: filename
      #:mode 'text
      #:exists 'truncate
  define-values: :source-path source-name must-be-dir?
    split-path: syntax-source: #'here
  fprintf: output-file
    string-append:
      "#lang racket/base\n\n"
      "; This file was autogenerated by ~a and not intended to be modifed by hand\n\n"
    source-name
  parameterize: (pretty-print-columns: columns)
    for-each:
      lambda: (s)
        pretty-write: s output-file
        fprintf: output-file "\n"
      program
  close-output-port: output-file

;----------------------------------------------------------------------
; The actual code follows
;----------------------------------------------------------------------

pretty-print-program: 100 "lispi.rkt" quote: (

;----------------------------------------------------------------------
; Options
;----------------------------------------------------------------------

define: neoteric-parens? #t

;----------------------------------------------------------------------

provide:
  make-lispi-readtable

require:
  racket/port
  racket/match
  syntax/readerr

define: make-lispi-readtable:
  lispi-readtable: null-indent null-indent

;----------------------------------------------------------------------
; The readtable
;----------------------------------------------------------------------

define: lispi-readtable: true-indent colon-indent
  make-readtable: #f
    #\newline 'terminating-macro     reader-dispatch: process-indent
    #\~       'terminating-macro     reader-dispatch: process-tilde
    #\;       'terminating-macro     reader-dispatch: process-line-comment
    #\:       'terminating-macro     reader-dispatch: process-colon       true-indent colon-indent
    #\(       'terminating-macro     reader-dispatch: process-open-parens true-indent colon-indent #\( #\)
    #\[       'terminating-macro     reader-dispatch: process-open-parens true-indent colon-indent #\[ #\]
    #\{       'terminating-macro     reader-dispatch: process-open-parens true-indent colon-indent #\{ #\}

    #\"       'terminating-macro     reader-dispatch: process-default     true-indent colon-indent
    #\'       'terminating-macro     reader-dispatch: process-default     true-indent colon-indent
    #\`       'terminating-macro     reader-dispatch: process-default     true-indent colon-indent
    #\,       'terminating-macro     reader-dispatch: process-default     true-indent colon-indent
    #\#       'terminating-macro     reader-dispatch: process-default     true-indent colon-indent

    #f        'non-terminating-macro reader-dispatch: process-datum       true-indent colon-indent

define: reader-dispatch: proc . args~ case-lambda:~
  ch:: in
    syntax->datum: apply: proc #f in ch args
  ch:: in src line col pos
    apply: proc src in ch args

;----------------------------------------------------------------------
; Readtable dispatch functions
;----------------------------------------------------------------------

; Don't modify how these are processed,
; just check if they're followed by a tail to support the neoteric form
define: process-default: src in ch true-indent colon-indent
  process-tail: src in true-indent colon-indent
    read-syntax/recursive: src in ch #f

define: process-indent: src in ch
  define: indent-match regexp-try-match: #px"^[[:space:]]*" in
  define: new-indent count-regex-indent: indent-match
  ; Normally we return the token following the newline as part of the newline construct
  ; This is improper use of the readtable though and it trips us up here - a newline
  ; followed by a close parenthesis or EOF shouldn't consume them, so we just return a comment
  cond:
    peek-eof         :(in): make-special-comment: #f
    peek-close-parens:(in): make-special-comment: #f
    else:
      read-syntax/recursive: src in #f lispi-readtable: new-indent new-indent

define: process-colon: src in ch true-indent colon-indent
  ; (printf "Raw Colon: [~s]\n" true-indent colon-indent)
  ; Raw colons disallow neoteric parens
  process-colon-extras: src in true-indent colon-indent #f #f

define: process-datum: src in ch true-indent colon-indent
  ; Read datum (all characters other than delimiters, plus our two new delimiters : and ~)
  define: datum-regex regexp-try-match: #px"^[^][)(}{[:space:]\",'`;:~]*" in
  define: datum string-append:~
    make-string: 1 ch
    bytes->string/utf-8: car: datum-regex
  ; (printf "datum ~s ~s\n" ch datum)
  process-tail: src in true-indent colon-indent
    to-syntax: src in datum

define: process-open-parens: src in ch true-indent colon-indent open-parens close-parens
  ; (printf "Open Parens: [~s]\n" open-parens close-parens)
  process-parens-list-and-tail: open-parens close-parens src in true-indent colon-indent

; Encountering a tilde outside of colon list processing is an error
define: process-tilde: src in ch
  read-error: src in 1 "a closing ~ requires an opening :"

; Don't consume newline as part of the comment
define: process-line-comment: src in ch
  make-special-comment: regexp-try-match: #px"^[^\n]*" in

;----------------------------------------------------------------------

; Defaulting to a huge indent makes nested colon lists always end on that same line
define: null-indent 999999

define: indent-regex #px"^[[:blank:]]*\n[[:space:]]*"

; A "tail" is a token following a token, while we still have access to the previous token (as stx)
; Similar concept to neoteric expressions, and used heavily for our colon list syntax
define: process-tail: src in true-indent colon-indent stx (skip-whitespace #t)
  cond:
    check-char:: in #\: skip-whitespace
      process-colon-extras: src in true-indent colon-indent stx
    else: stx

; A colon can be followed by modifier characters, which we process here
define: process-colon-extras: src in true-indent colon-indent stx (neoteric? neoteric-parens?)
  cond:
    check-char:: in #\~ #f
      process-tilde-list-and-tail: src in true-indent colon-indent stx
    and:: neoteric? cond:~
      (check-char in #\( #f): process-parens-list-and-tail: #\( #\) src in true-indent colon-indent stx
      (check-char in #\[ #f): process-parens-list-and-tail: #\[ #\] src in true-indent colon-indent stx
      (check-char in #\{ #f): process-parens-list-and-tail: #\{ #\} src in true-indent colon-indent stx
      else: #f
    else: process-colon-list-and-tail: src in true-indent colon-indent stx

define: process-tilde-list-and-tail: src in true-indent colon-indent (initial-stx #f)
  process-tail: src in true-indent colon-indent
    process-colon-list: src in true-indent initial-stx true-indent null-indent #f

define: process-colon-list-and-tail: src in true-indent colon-indent (initial-stx #f)
  process-tail: src in true-indent colon-indent
    process-colon-list: src in colon-indent initial-stx true-indent null-indent #f

; colon-indent is used by nested colon lists
; true-indent is used by colon-tilde (:~) lists
define: process-colon-list: src in end-indent initial-stx true-indent colon-indent improper-list
  cond:
    :initial-stx add-token-to-list:~ improper-list
      ; Nested tail tokens aren't allowed to have whitespace in-between
      ; Eg "proc::" means "((proc" while "proc: :" means "(proc ("
      process-tail: src in true-indent colon-indent initial-stx #f
      process-colon-list: src in end-indent #f true-indent colon-indent improper-list
    :peek-eof         : in                    ~ null
    :peek-close-parens: in                    ~ null
    :regexp-try-match : #px"^[[:blank:]]*~" in~ null ; If present, consume "~" on same line, and end list
    :regexp-try-match :(indent-regex peeking-input-port: in) => lambda:~ :indent-match
      define: new-indent count-regex-indent: indent-match
      cond:
        :<=: new-indent end-indent              ~ null ; Indent level has returned to the starting indent
        :< : new-indent colon-indent null-indent~ null ; Dedent compared to previous line
        :else
          regexp-try-match: indent-regex in ; Consume indent
          process-colon-list: src in end-indent #f new-indent new-indent improper-list ; Continue existing list
    :regexp-try-match: #px"^[[:space:]]*\\.[[:space:]]" peeking-input-port: in
      ; Todo: Need to check that the period is in the correct place to denote improper list
      regexp-try-match: #px"^[[:space:]]*\\." in
      process-colon-list: src in end-indent initial-stx true-indent colon-indent #t
    :else add-token-to-list:~ improper-list
      read-syntax/recursive: src in #f lispi-readtable: true-indent colon-indent
      process-colon-list: src in end-indent #f true-indent colon-indent improper-list

define: process-parens-list-and-tail: open-parens close-parens src in true-indent colon-indent (initial-stx #f)
  process-tail: src in true-indent colon-indent
    process-parens-list: open-parens close-parens src in initial-stx true-indent null-indent #f

define: process-parens-list: open-parens close-parens src in initial-stx true-indent colon-indent improper-list
  cond:
    :initial-stx add-token-to-list:~ improper-list
      ; Neoteric expressions can't have nested token tails so we don't process-tail
      ; Eg writeln:(:+ 1 2) - should print 3, not give an error
      ; The second colon should not be placed before the writeln
      initial-stx
      process-parens-list: open-parens close-parens src in #f true-indent colon-indent improper-list
    :peek-eof: in~ read-error:~ src in 1
      format: "expected a `~a' to close `~a'"
        close-parens open-parens
    :read-close-parens:(in) => lambda:~ :actual-parens
      define-values: (line col pos) port-next-location: in
      if: equal?: close-parens actual-parens
        null ; End list if parens match
        read-error: src in 1
          format: "expected `~a' to close preceding `~a', found instead `~a'"
            close-parens open-parens actual-parens
    :regexp-try-match:(indent-regex in) => lambda:~ :indent-match
      define: new-indent count-regex-indent: indent-match
      process-parens-list: open-parens close-parens src in #f new-indent new-indent improper-list
    :regexp-try-match: #px"^[[:space:]]*\\.[[:space:]]" peeking-input-port: in
      ; Todo: Need to check that the period is in the correct place to denote improper list
      regexp-try-match: #px"^[[:space:]]*\\." in
      process-parens-list: open-parens close-parens src in #f true-indent colon-indent #t
    :else add-token-to-list:~ improper-list
      read-syntax/recursive: src in #f lispi-readtable: true-indent colon-indent
      process-parens-list: open-parens close-parens src in #f true-indent colon-indent improper-list

define: add-token-to-list: improper-list token lst
  cond:
    special-comment?:: token ; Ignore comments
      lst
    and:: improper-list null?: lst ; If list is improper don't cons on a null ending
      token
    else:
      cons: token lst

;----------------------------------------------------------------------
; Utilities
;----------------------------------------------------------------------

; Calculate the amount of indent that the given string represents
define: count-indent: token
  ; Skip over any lines that only contain whitespace and just count the final-indent
  define: final-indent regexp-match: #px"^(?:[^\n]*\n)*(.*)" token
  for/sum: : ch:(in-string: cadr: final-indent)
    match: ch
      #\space: 1
      #\tab  : 8 ; TODO: this isn't right, tabs move to the next multiple of 8, not always add 8
      _      : 0

; Calculate the amount of indent that the given regex result represents
define: count-regex-indent: regex-result
  count-indent: bytes->string/utf-8: car: regex-result

; True if the next char matches the given char, optionally skipping whitespace
define: check-char: in ch (skip-whitespace #t)
  define: blank-regex #px"^[[:blank:]]*"
  define: in-peek peeking-input-port: in
  and: skip-whitespace
    regexp-try-match: blank-regex in-peek
  cond:
    equal?:: read-char:(in-peek) ch
      port-commit-peeked: file-position:in-peek~ port-progress-evt:in~ always-evt in
      ch
    else: #f

; True if there is no next char
define: peek-eof: in
  define: in-peek peeking-input-port: in
  regexp-try-match: #px"^[[:space:]]*" in-peek
  eof-object?: peek-char: in-peek

; True if the next char after whitespace is a close parens
define: peek-close-parens: in
  regexp-try-match: #px"^[[:space:]]*[])}]" peeking-input-port:(in)

; Returns which of )]} is the next token, or false if it's not a close parens at all
define: read-close-parens: in
  cond:
    :regexp-try-match:(#px"^[[:space:]]*([])}])" in) => lambda:~ :regexp-result
      string-ref: (bytes->string/utf-8 cadr: regexp-result) 0
    :else #f

; Calculate src location for error reporting
define: read-error: src in span str
  define-values: (line col pos) port-next-location: in
  raise-read-error: str src line (- col span) (- pos span) span

; Convert a datum (as a string) to a syntax object, taking its position from the given port
define: to-syntax: src in datum
  define-values: (line col pos) port-next-location: in
  define: l string-length: datum
  datum->syntax:
    #f
    syntax-e:
      read-syntax/recursive: src (open-input-string datum) #f #f
    list: src line (- col l) (- pos l) l

;----------------------------------------------------------------------

) ; End pretty-print list

