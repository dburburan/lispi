#lang racket/base

; This file was autogenerated by lispi-generator.rkti and not intended to be modifed by hand

(define neoteric-parens? #t)

(provide make-lispi-readtable)

(require racket/port racket/match syntax/readerr)

(define (make-lispi-readtable) (lispi-readtable null-indent null-indent))

(define (lispi-readtable true-indent colon-indent)
  (make-readtable
   #f
   #\newline
   'terminating-macro
   (reader-dispatch process-indent)
   #\;
   'terminating-macro
   (reader-dispatch process-semi-colon)
   #\/
   'non-terminating-macro
   (reader-dispatch process-line-comment)
   #\:
   'terminating-macro
   (reader-dispatch process-colon true-indent colon-indent)
   #\(
   'terminating-macro
   (reader-dispatch process-open-parens true-indent colon-indent #\( #\))
   #\[
   'terminating-macro
   (reader-dispatch process-open-parens true-indent colon-indent #\[ #\])
   #\{
   'terminating-macro
   (reader-dispatch process-open-parens true-indent colon-indent #\{ #\})
   #\"
   'terminating-macro
   (reader-dispatch process-default true-indent colon-indent)
   #\'
   'terminating-macro
   (reader-dispatch process-default true-indent colon-indent)
   #\`
   'terminating-macro
   (reader-dispatch process-default true-indent colon-indent)
   #\,
   'terminating-macro
   (reader-dispatch process-default true-indent colon-indent)
   #\#
   'terminating-macro
   (reader-dispatch process-default true-indent colon-indent)
   #f
   'non-terminating-macro
   (reader-dispatch process-datum true-indent colon-indent)))

(define (reader-dispatch proc . args)
  (case-lambda
   ((ch in) (syntax->datum (apply proc #f in ch args)))
   ((ch in src line col pos) (apply proc src in ch args))))

(define (process-default src in ch true-indent colon-indent)
  (process-tail src in true-indent colon-indent (read-syntax/recursive src in ch #f)))

(define (process-indent src in ch)
  (define indent-match (regexp-try-match #px"^[[:space:]]*" in))
  (define new-indent (count-regex-indent indent-match))
  (cond
   ((peek-eof in) (make-special-comment #f))
   ((peek-close-parens in) (make-special-comment #f))
   (else (read-syntax/recursive src in #f (lispi-readtable new-indent new-indent)))))

(define (process-colon src in ch true-indent colon-indent)
  (process-colon-extras src in true-indent colon-indent #f #f))

(define (process-datum src in ch true-indent colon-indent)
  (define datum-regex (regexp-try-match #px"^[^][)(}{[:space:]\",'`;:]*" in))
  (define datum (string-append (make-string 1 ch) (bytes->string/utf-8 (car datum-regex))))
  (process-tail src in true-indent colon-indent (to-syntax src in datum)))

(define (process-open-parens src in ch true-indent colon-indent open-parens close-parens)
  (process-parens-list-and-tail open-parens close-parens src in true-indent colon-indent))

(define (process-semi-colon src in ch)
  (define-values (line col pos) (port-next-location in))
  (read-error src in 1 "a closing ; requires an opening :"))

(define (process-line-comment src in ch)
  (if (equal? (peek-char in) #\/)
    (make-special-comment (regexp-try-match #px"^[^\n]*" in))
    (read-syntax/recursive src in ch)))

(define null-indent 999999)

(define indent-regex #px"^[[:blank:]]*\n[[:space:]]*")

(define (process-tail src in true-indent colon-indent stx (skip-whitespace #t))
  (cond
   ((check-char in #\: skip-whitespace) (process-colon-extras src in true-indent colon-indent stx))
   (else stx)))

(define (process-colon-extras src in true-indent colon-indent stx (neoteric? neoteric-parens?))
  (cond
   ((check-char in #\~ #f) (process-tilde-list-and-tail src in true-indent colon-indent stx))
   ((and neoteric?
         (cond
          ((check-char in #\( #f)
           (process-parens-list-and-tail #\( #\) src in true-indent colon-indent stx))
          ((check-char in #\[ #f)
           (process-parens-list-and-tail #\[ #\] src in true-indent colon-indent stx))
          ((check-char in #\{ #f)
           (process-parens-list-and-tail #\{ #\} src in true-indent colon-indent stx))
          (else #f))))
   (else (process-colon-list-and-tail src in true-indent colon-indent stx))))

(define (process-tilde-list-and-tail src in true-indent colon-indent (initial-stx #f))
  (process-tail
   src
   in
   true-indent
   colon-indent
   (process-colon-list src in true-indent initial-stx true-indent null-indent #f)))

(define (process-colon-list-and-tail src in true-indent colon-indent (initial-stx #f))
  (process-tail
   src
   in
   true-indent
   colon-indent
   (process-colon-list src in colon-indent initial-stx true-indent null-indent #f)))

(define (process-colon-list src in end-indent initial-stx true-indent colon-indent improper-list)
  (cond
   (initial-stx
    (add-token-to-list
     improper-list
     (process-tail src in true-indent colon-indent initial-stx #f)
     (process-colon-list src in end-indent #f true-indent colon-indent improper-list)))
   ((peek-eof in) null)
   ((peek-close-parens in) null)
   ((regexp-try-match #px"^[[:blank:]]*;" in) null)
   ((regexp-try-match indent-regex (peeking-input-port in))
    =>
    (lambda (indent-match)
      (define new-indent (count-regex-indent indent-match))
      (cond
       ((<= new-indent end-indent) null)
       ((< new-indent colon-indent null-indent) null)
       (else
        (regexp-try-match indent-regex in)
        (process-colon-list src in end-indent #f new-indent new-indent improper-list)))))
   ((regexp-try-match #px"^[[:space:]]*\\.[[:space:]]" (peeking-input-port in))
    (regexp-try-match #px"^[[:space:]]*\\." in)
    (process-colon-list src in end-indent initial-stx true-indent colon-indent #t))
   (else
    (add-token-to-list
     improper-list
     (read-syntax/recursive src in #f (lispi-readtable true-indent colon-indent))
     (process-colon-list src in end-indent #f true-indent colon-indent improper-list)))))

(define (process-parens-list-and-tail
         open-parens
         close-parens
         src
         in
         true-indent
         colon-indent
         (initial-stx #f))
  (process-tail
   src
   in
   true-indent
   colon-indent
   (process-parens-list open-parens close-parens src in initial-stx true-indent null-indent #f)))

(define (process-parens-list
         open-parens
         close-parens
         src
         in
         initial-stx
         true-indent
         colon-indent
         improper-list)
  (cond
   (initial-stx
    (add-token-to-list
     improper-list
     initial-stx
     (process-parens-list
      open-parens
      close-parens
      src
      in
      #f
      true-indent
      colon-indent
      improper-list)))
   ((read-close-parens in)
    =>
    (lambda (actual-parens)
      (define-values (line col pos) (port-next-location in))
      (if (equal? close-parens actual-parens)
        null
        (read-error
         src
         in
         1
         (format
          "expected `~a' to close preceding `~a', found instead `~a'"
          close-parens
          open-parens
          actual-parens)))))
   ((regexp-try-match indent-regex in)
    =>
    (lambda (indent-match)
      (define new-indent (count-regex-indent indent-match))
      (process-parens-list open-parens close-parens src in #f new-indent new-indent improper-list)))
   ((regexp-try-match #px"^[[:space:]]*\\.[[:space:]]" (peeking-input-port in))
    (regexp-try-match #px"^[[:space:]]*\\." in)
    (process-parens-list open-parens close-parens src in #f true-indent colon-indent #t))
   (else
    (add-token-to-list
     improper-list
     (read-syntax/recursive src in #f (lispi-readtable true-indent colon-indent))
     (process-parens-list
      open-parens
      close-parens
      src
      in
      #f
      true-indent
      colon-indent
      improper-list)))))

(define (add-token-to-list improper-list token lst)
  (cond
   ((special-comment? token) lst)
   ((and improper-list (null? lst)) token)
   (else (cons token lst))))

(define (count-indent token)
  (define final-indent (regexp-match #px"^(?:[^\n]*\n)*(.*)" token))
  (for/sum ((ch (in-string (cadr final-indent)))) (match ch (#\space 1) (#\tab 8) (_ 0))))

(define (count-regex-indent regex-result) (count-indent (bytes->string/utf-8 (car regex-result))))

(define (check-char in ch (skip-whitespace #t))
  (define blank-regex #px"^[[:blank:]]*")
  (define in-peek (peeking-input-port in))
  (and skip-whitespace (regexp-try-match blank-regex in-peek))
  (cond
   ((equal? (read-char in-peek) ch)
    (port-commit-peeked (file-position in-peek) (port-progress-evt in) always-evt in)
    ch)
   (else #f)))

(define (peek-eof in)
  (define in-peek (peeking-input-port in))
  (regexp-try-match #px"^[[:space:]]*" in-peek)
  (eof-object? (peek-char in-peek)))

(define (peek-close-parens in) (regexp-try-match #px"^[[:space:]]*[])}]" (peeking-input-port in)))

(define (read-close-parens in)
  (cond
   ((regexp-try-match #px"^[[:space:]]*([])}])" in)
    =>
    (lambda (regexp-result) (string-ref (bytes->string/utf-8 (cadr regexp-result)) 0)))
   (else #f)))

(define (read-error src in span str)
  (define-values (line col pos) (port-next-location in))
  (raise-read-error str src line (- col span) (- pos span) span))

(define (to-syntax src in datum)
  (define-values (line col pos) (port-next-location in))
  (define l (string-length datum))
  (datum->syntax
   #f
   (syntax-e (read-syntax/recursive src (open-input-string datum) #f #f))
   (list src line (- col l) (- pos l) l)))

